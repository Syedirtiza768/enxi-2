import * as XLSX from 'xlsx';
import { format } from 'date-fns';

export interface ExcelStyleDefinition {
  font?: {
    bold?: boolean;
    italic?: boolean;
    underline?: boolean;
    color?: { rgb: string };
    size?: number;
    name?: string;
  };
  fill?: {
    patternType?: 'solid' | 'mediumGray' | 'darkGray' | 'lightGray';
    fgColor?: { rgb: string };
    bgColor?: { rgb: string };
  };
  border?: {
    top?: { style: 'thin' | 'medium' | 'thick'; color: { rgb: string } };
    bottom?: { style: 'thin' | 'medium' | 'thick'; color: { rgb: string } };
    left?: { style: 'thin' | 'medium' | 'thick'; color: { rgb: string } };
    right?: { style: 'thin' | 'medium' | 'thick'; color: { rgb: string } };
  };
  alignment?: {
    horizontal?: 'left' | 'center' | 'right';
    vertical?: 'top' | 'middle' | 'bottom';
    wrapText?: boolean;
  };
  numFmt?: string;
}

export interface ExcelConditionalFormatRule {
  type: 'cellValue' | 'formula' | 'colorScale' | 'dataBar' | 'iconSet';
  operator?: 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'between' | 'contains';
  value1?: any;
  value2?: any;
  format?: ExcelStyleDefinition;
  formula?: string;
  colorScale?: {
    minColor: string;
    midColor?: string;
    maxColor: string;
  };
  iconSet?: 'arrows' | 'flags' | 'traffic' | 'symbols' | 'indicators';
}

export interface ExcelChartDefinition {
  type: 'column' | 'bar' | 'line' | 'pie' | 'area' | 'scatter' | 'combo';
  title: string;
  dataRange: string;
  position: {
    col: number;
    row: number;
    colOffset?: number;
    rowOffset?: number;
  };
  size?: {
    width: number;
    height: number;
  };
  series?: Array<{
    name: string;
    values: string;
    categories?: string;
    color?: string;
  }>;
  options?: {
    showLegend?: boolean;
    showDataLabels?: boolean;
    gridlines?: boolean;
    theme?: 'colorful' | 'monochromatic' | 'office';
    xAxisTitle?: string;
    yAxisTitle?: string;
  };
}

export interface ExcelImageDefinition {
  path: string | ArrayBuffer;
  position: {
    col: number;
    row: number;
    colOffset?: number;
    rowOffset?: number;
  };
  size?: {
    width: number;
    height: number;
  };
  name?: string;
  description?: string;
}

export interface ExcelWorksheetOptions {
  autoFilter?: boolean;
  freezePanes?: {
    row?: number;
    col?: number;
  };
  protection?: {
    sheet?: boolean;
    password?: string;
    allowedActions?: Array<'selectLockedCells' | 'selectUnlockedCells' | 'formatCells' | 'formatColumns' | 'formatRows' | 'insertColumns' | 'insertRows' | 'insertHyperlinks' | 'deleteColumns' | 'deleteRows' | 'sort' | 'autoFilter' | 'pivotTables'>;
  };
  pageSetup?: {
    orientation?: 'portrait' | 'landscape';
    paperSize?: number; // Excel paper size constants
    fitToPage?: boolean;
    fitToWidth?: number;
    fitToHeight?: number;
    margins?: {
      left: number;
      right: number;
      top: number;
      bottom: number;
      header: number;
      footer: number;
    };
    header?: string;
    footer?: string;
    centerHorizontally?: boolean;
    centerVertically?: boolean;
  };
  printArea?: string;
  printTitles?: {
    rows?: string; // e.g., "1:1"
    columns?: string; // e.g., "A:A"
  };
}

/**
 * Create an Excel workbook with advanced formatting and features
 */
export class ExcelWorkbookBuilder {
  private workbook: XLSX.WorkBook;
  private styles: Map<string, ExcelStyleDefinition>;

  constructor() {
    this.workbook = XLSX.utils.book_new();
    this.styles = new Map();
    this.initializeWorkbook();
  }

  private initializeWorkbook() {
    // Set workbook properties
    this.workbook.Props = {
      Title: 'Excel Export',
      Subject: 'Data Export',
      Author: 'Excel Exporter',
      Manager: '',
      Company: 'Enxi ERP',
      Category: 'Report',
      Keywords: 'export,data,excel',
      Comments: 'Generated by Enxi ERP Excel Exporter',
      LastAuthor: 'Excel Exporter',
      CreatedDate: new Date()
    };

    // Set default view options
    this.workbook.Workbook = {
      Views: [{
        xWindow: 240,
        yWindow: 120,
        windowWidth: 20000,
        windowHeight: 10000
      }]
    };
  }

  /**
   * Add a worksheet with data and formatting
   */
  addWorksheet(
    name: string,
    data: any[][],
    columnConfigs?: Array<{
      width?: number;
      style?: ExcelStyleDefinition;
      conditionalFormatting?: ExcelConditionalFormatRule[];
    }>,
    options?: ExcelWorksheetOptions
  ): void {
    // Create worksheet from data
    const ws = XLSX.utils.aoa_to_sheet(data);

    // Apply column configurations
    if (columnConfigs) {
      const colWidths = columnConfigs.map(config => ({ wch: config.width || 15 }));
      ws['!cols'] = colWidths;

      // Apply cell styles (simplified for this implementation)
      columnConfigs.forEach((config, colIndex) => {
        if (config.style) {
          // Apply styles to header row
          const headerCell = ws[XLSX.utils.encode_cell({ r: 0, c: colIndex })];
          if (headerCell) {
            headerCell.s = this.convertStyleToXLSX(config.style);
          }
        }
      });
    }

    // Apply worksheet options
    if (options) {
      this.applyWorksheetOptions(ws, options, data.length, (columnConfigs?.length || data[0]?.length || 0));
    }

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(this.workbook, ws, name);
  }

  /**
   * Add a worksheet from object array with column mapping
   */
  addWorksheetFromObjects<T extends Record<string, any>>(
    name: string,
    data: T[],
    columns: Array<{
      key: keyof T;
      label: string;
      type?: 'string' | 'number' | 'date' | 'currency' | 'boolean' | 'formula';
      width?: number;
      style?: ExcelStyleDefinition;
      format?: string;
      formula?: string;
    }>,
    options?: ExcelWorksheetOptions
  ): void {
    // Convert object data to 2D array
    const headers = columns.map(col => col.label);
    const rows = data.map(row => 
      columns.map(col => {
        let value = row[col.key];
        
        // Apply type-specific formatting
        switch (col.type) {
          case 'date':
            if (value instanceof Date) {
              return value;
            } else if (typeof value === 'string') {
              const date = new Date(value);
              return isNaN(date.getTime()) ? value : date;
            }
            break;
          case 'currency':
            return typeof value === 'number' ? value : parseFloat(value) || 0;
          case 'boolean':
            return value ? 'Yes' : 'No';
          case 'formula':
            if (col.formula) {
              // Simple formula replacement - in a real implementation, this would be more sophisticated
              return { f: col.formula };
            }
            break;
        }
        
        return value ?? '';
      })
    );

    const worksheetData = [headers, ...rows];
    
    // Create column configs
    const columnConfigs = columns.map(col => ({
      width: col.width,
      style: col.style
    }));

    this.addWorksheet(name, worksheetData, columnConfigs, options);
  }

  /**
   * Add charts to a worksheet (simplified implementation)
   */
  addChartsToWorksheet(worksheetName: string, charts: ExcelChartDefinition[]): void {
    // In a full implementation, this would use a library like ExcelJS
    // For now, we'll store chart information for potential future use
    console.log(`Charts would be added to ${worksheetName}:`, charts);
  }

  /**
   * Add images to a worksheet (simplified implementation)
   */
  addImagesToWorksheet(worksheetName: string, images: ExcelImageDefinition[]): void {
    // In a full implementation, this would embed images
    console.log(`Images would be added to ${worksheetName}:`, images);
  }

  /**
   * Apply conditional formatting to a range (simplified implementation)
   */
  addConditionalFormatting(
    worksheetName: string,
    range: string,
    rules: ExcelConditionalFormatRule[]
  ): void {
    // In a full implementation, this would apply conditional formatting
    console.log(`Conditional formatting would be applied to ${worksheetName} range ${range}:`, rules);
  }

  /**
   * Set workbook metadata
   */
  setMetadata(metadata: {
    title?: string;
    subject?: string;
    author?: string;
    company?: string;
    category?: string;
    keywords?: string[];
    comments?: string;
  }): void {
    this.workbook.Props = {
      ...this.workbook.Props,
      ...metadata,
      Keywords: metadata.keywords?.join(',') || this.workbook.Props?.Keywords,
      CreatedDate: new Date()
    };
  }

  /**
   * Generate the Excel file as ArrayBuffer
   */
  build(options?: {
    compression?: boolean;
    password?: string;
  }): ArrayBuffer {
    const writeOptions: XLSX.WritingOptions = {
      bookType: 'xlsx',
      type: 'array',
      compression: options?.compression !== false
    };

    // Password protection would require additional libraries
    if (options?.password) {
      console.warn('Password protection requires additional Excel libraries');
    }

    return XLSX.write(this.workbook, writeOptions);
  }

  /**
   * Get the workbook for advanced operations
   */
  getWorkbook(): XLSX.WorkBook {
    return this.workbook;
  }

  private applyWorksheetOptions(
    ws: XLSX.WorkSheet,
    options: ExcelWorksheetOptions,
    rowCount: number,
    colCount: number
  ): void {
    // Auto filter
    if (options.autoFilter && rowCount > 1) {
      ws['!autofilter'] = {
        ref: XLSX.utils.encode_range({
          s: { c: 0, r: 0 },
          e: { c: colCount - 1, r: rowCount - 1 }
        })
      };
    }

    // Freeze panes
    if (options.freezePanes) {
      ws['!freeze'] = {
        xSplit: options.freezePanes.col || 0,
        ySplit: options.freezePanes.row || 0
      };
    }

    // Print area
    if (options.printArea) {
      ws['!printArea'] = options.printArea;
    }

    // Print titles
    if (options.printTitles) {
      ws['!printTitles'] = options.printTitles;
    }

    // Page setup
    if (options.pageSetup) {
      ws['!pageSetup'] = {
        orientation: options.pageSetup.orientation === 'landscape' ? 2 : 1,
        paperSize: options.pageSetup.paperSize || 1,
        scale: options.pageSetup.fitToPage ? undefined : 100,
        fitToWidth: options.pageSetup.fitToWidth,
        fitToHeight: options.pageSetup.fitToHeight,
        margins: options.pageSetup.margins ? {
          left: options.pageSetup.margins.left / 25.4, // Convert mm to inches
          right: options.pageSetup.margins.right / 25.4,
          top: options.pageSetup.margins.top / 25.4,
          bottom: options.pageSetup.margins.bottom / 25.4,
          header: options.pageSetup.margins.header / 25.4,
          footer: options.pageSetup.margins.footer / 25.4
        } : undefined,
        centerHorizontally: options.pageSetup.centerHorizontally,
        centerVertically: options.pageSetup.centerVertically
      };

      // Headers and footers
      if (options.pageSetup.header || options.pageSetup.footer) {
        ws['!pageMargins'] = {
          header: options.pageSetup.header || '',
          footer: options.pageSetup.footer || ''
        };
      }
    }

    // Sheet protection (simplified)
    if (options.protection?.sheet) {
      ws['!protect'] = {
        password: options.protection.password,
        selectLockedCells: options.protection.allowedActions?.includes('selectLockedCells') !== false,
        selectUnlockedCells: options.protection.allowedActions?.includes('selectUnlockedCells') !== false,
        formatCells: options.protection.allowedActions?.includes('formatCells') || false,
        formatColumns: options.protection.allowedActions?.includes('formatColumns') || false,
        formatRows: options.protection.allowedActions?.includes('formatRows') || false,
        insertColumns: options.protection.allowedActions?.includes('insertColumns') || false,
        insertRows: options.protection.allowedActions?.includes('insertRows') || false,
        insertHyperlinks: options.protection.allowedActions?.includes('insertHyperlinks') || false,
        deleteColumns: options.protection.allowedActions?.includes('deleteColumns') || false,
        deleteRows: options.protection.allowedActions?.includes('deleteRows') || false,
        sort: options.protection.allowedActions?.includes('sort') || false,
        autoFilter: options.protection.allowedActions?.includes('autoFilter') || false,
        pivotTables: options.protection.allowedActions?.includes('pivotTables') || false
      };
    }
  }

  private convertStyleToXLSX(style: ExcelStyleDefinition): any {
    // Convert our style definition to XLSX format
    const xlsxStyle: any = {};

    if (style.font) {
      xlsxStyle.font = {
        bold: style.font.bold,
        italic: style.font.italic,
        underline: style.font.underline,
        color: style.font.color,
        sz: style.font.size,
        name: style.font.name
      };
    }

    if (style.fill) {
      xlsxStyle.fill = {
        patternType: style.fill.patternType || 'solid',
        fgColor: style.fill.fgColor,
        bgColor: style.fill.bgColor
      };
    }

    if (style.border) {
      xlsxStyle.border = style.border;
    }

    if (style.alignment) {
      xlsxStyle.alignment = style.alignment;
    }

    if (style.numFmt) {
      xlsxStyle.numFmt = style.numFmt;
    }

    return xlsxStyle;
  }
}

/**
 * Utility functions for Excel operations
 */
export class ExcelUtils {
  /**
   * Convert column number to Excel column letter
   */
  static numberToColumn(num: number): string {
    let result = '';
    while (num > 0) {
      num--;
      result = String.fromCharCode(65 + (num % 26)) + result;
      num = Math.floor(num / 26);
    }
    return result;
  }

  /**
   * Convert Excel column letter to number
   */
  static columnToNumber(col: string): number {
    let result = 0;
    for (let i = 0; i < col.length; i++) {
      result = result * 26 + (col.charCodeAt(i) - 64);
    }
    return result;
  }

  /**
   * Create Excel cell reference
   */
  static cellRef(row: number, col: number): string {
    return `${this.numberToColumn(col)}${row}`;
  }

  /**
   * Create Excel range reference
   */
  static rangeRef(startRow: number, startCol: number, endRow: number, endCol: number): string {
    return `${this.cellRef(startRow, startCol)}:${this.cellRef(endRow, endCol)}`;
  }

  /**
   * Format value based on column type
   */
  static formatValue(value: any, type: string, format?: string): any {
    switch (type) {
      case 'currency':
        if (typeof value === 'number') {
          return value;
        }
        return parseFloat(value) || 0;

      case 'percentage':
        if (typeof value === 'number') {
          return value / 100; // Excel expects percentages as decimals
        }
        return (parseFloat(value) || 0) / 100;

      case 'date':
        if (value instanceof Date) {
          return value;
        }
        if (typeof value === 'string') {
          const date = new Date(value);
          return isNaN(date.getTime()) ? value : date;
        }
        return value;

      case 'boolean':
        return Boolean(value);

      case 'number':
        if (typeof value === 'number') {
          return value;
        }
        return parseFloat(value) || 0;

      default:
        return value?.toString() || '';
    }
  }

  /**
   * Get Excel number format string for different types
   */
  static getNumberFormat(type: string, currency: string = 'AED'): string {
    switch (type) {
      case 'currency':
        return `"${currency}" #,##0.00`;
      case 'percentage':
        return '0.00%';
      case 'date':
        return 'dd/mm/yyyy';
      case 'datetime':
        return 'dd/mm/yyyy hh:mm';
      case 'number':
        return '#,##0.00';
      case 'integer':
        return '#,##0';
      default:
        return '@'; // Text format
    }
  }

  /**
   * Create predefined styles
   */
  static createPredefinedStyles(): Map<string, ExcelStyleDefinition> {
    const styles = new Map<string, ExcelStyleDefinition>();

    // Header style
    styles.set('header', {
      font: {
        bold: true,
        color: { rgb: 'FFFFFF' },
        size: 12
      },
      fill: {
        patternType: 'solid',
        fgColor: { rgb: '366092' }
      },
      alignment: {
        horizontal: 'center',
        vertical: 'middle'
      },
      border: {
        top: { style: 'thin', color: { rgb: '000000' } },
        bottom: { style: 'thin', color: { rgb: '000000' } },
        left: { style: 'thin', color: { rgb: '000000' } },
        right: { style: 'thin', color: { rgb: '000000' } }
      }
    });

    // Alternate row style
    styles.set('alternateRow', {
      fill: {
        patternType: 'solid',
        fgColor: { rgb: 'F2F2F2' }
      }
    });

    // Currency style
    styles.set('currency', {
      numFmt: 'AED #,##0.00',
      alignment: {
        horizontal: 'right'
      }
    });

    // Date style
    styles.set('date', {
      numFmt: 'dd/mm/yyyy',
      alignment: {
        horizontal: 'center'
      }
    });

    // Percentage style
    styles.set('percentage', {
      numFmt: '0.00%',
      alignment: {
        horizontal: 'right'
      }
    });

    // Total row style
    styles.set('total', {
      font: {
        bold: true,
        size: 11
      },
      fill: {
        patternType: 'solid',
        fgColor: { rgb: 'E6E6E6' }
      },
      border: {
        top: { style: 'medium', color: { rgb: '000000' } }
      }
    });

    return styles;
  }

  /**
   * Estimate file size based on data
   */
  static estimateFileSize(
    rowCount: number,
    columnCount: number,
    hasFormulas: boolean = false,
    hasCharts: boolean = false,
    compression: boolean = true
  ): number {
    // Base calculation
    const avgCellSize = hasFormulas ? 30 : 20; // Bytes per cell
    const baseSize = rowCount * columnCount * avgCellSize;
    
    // Excel overhead
    const excelOverhead = baseSize * 0.5;
    
    // Chart overhead
    const chartOverhead = hasCharts ? 50000 : 0; // ~50KB per chart
    
    // Total uncompressed size
    const totalSize = baseSize + excelOverhead + chartOverhead;
    
    // Apply compression factor
    return compression ? totalSize * 0.3 : totalSize;
  }

  /**
   * Validate Excel range reference
   */
  static isValidRange(range: string): boolean {
    const rangePattern = /^[A-Z]+\d+:[A-Z]+\d+$/;
    return rangePattern.test(range);
  }

  /**
   * Parse Excel range to get bounds
   */
  static parseRange(range: string): {
    startRow: number;
    startCol: number;
    endRow: number;
    endCol: number;
  } | null {
    if (!this.isValidRange(range)) {
      return null;
    }

    const [start, end] = range.split(':');
    const startMatch = start.match(/([A-Z]+)(\d+)/);
    const endMatch = end.match(/([A-Z]+)(\d+)/);

    if (!startMatch || !endMatch) {
      return null;
    }

    return {
      startRow: parseInt(startMatch[2]),
      startCol: this.columnToNumber(startMatch[1]),
      endRow: parseInt(endMatch[2]),
      endCol: this.columnToNumber(endMatch[1])
    };
  }
}

export default ExcelWorkbookBuilder;